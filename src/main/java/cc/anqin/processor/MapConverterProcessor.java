package cc.anqin.processor;

import cc.anqin.processor.annotation.AutoToMap;
import cc.anqin.processor.base.ConvertMap;
import cc.anqin.processor.util.CollectFields;
import com.squareup.javapoet.*;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import static cc.anqin.processor.base.ConvertMap.PACKAGE_NAME;

/**
 * <p>Map转换器处理器</p>
 *
 * @author Mr.An
 * @since 2024/11/18
 */
@SupportedAnnotationTypes("cc.anqin.processor.annotation.AutoToMap")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MapConverterProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(AutoToMap.class)) {
            if (element instanceof TypeElement) {
                TypeElement typeElement = (TypeElement) element;
                generateMethod(typeElement);
            }
        }
        return true;
    }

    private void generateMethod(TypeElement typeElement) {

        String className = ConvertMap.getConvertName(typeElement.getQualifiedName().toString());

        String packageName = processingEnv.getElementUtils().getPackageOf(typeElement).toString();

        System.out.println("Generating file: " + PACKAGE_NAME + "." + className);

        // 创建 Spring 的 @Generated 注解
        AnnotationSpec componentAnnotation = AnnotationSpec
                .builder(ClassName.get("cc.anqin.processor.annotation", "Generated"))
                .addMember("value", "$S", "cc.anqin.processor.MapConverterProcessor") // 添加生成器名称
                .addMember("date", "$S", LocalDateTime.now())        // 添加当前日期
                .addMember("comments", "$S", "Generated by MapConverterProcessor; Introduction: https://anqin.cc/")   // 添加注释
                .build();


        // 创建实现 MappingConvert 接口的类
        TypeSpec mapConverterClass = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(componentAnnotation)
                .addSuperinterface(ParameterizedTypeName.get(
                        ClassName.get("cc.anqin.processor.base", "MappingConvert"),
                        TypeName.get(typeElement.asType())
                ))
                .addMethod(toMap(typeElement))
                .addMethod(toBean(typeElement))
                .build();

        write(packageName, mapConverterClass);
    }


    private MethodSpec toMap(TypeElement typeElement) {

        // 创建 toMap 方法
        MethodSpec.Builder toMapBuilder = MethodSpec.methodBuilder("toMap")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .returns(ParameterizedTypeName.get(Map.class, String.class, Object.class))
                .addParameter(TypeName.get(typeElement.asType()), "entity")
                .beginControlFlow("if (entity == null)") // 添加空检查
                .addStatement("return $T.emptyMap()", ClassName.get("java.util", "Collections")) // 如果 dataMap 为空，返回新实例
                .endControlFlow();

        // 初始化 Map
        toMapBuilder.addStatement("$T<String, Object> map = new $T<>()", Map.class, HashMap.class);

        // 遍历字段（包含父类）
        CollectFields.toMapCollectFields(typeElement, toMapBuilder, processingEnv);

        toMapBuilder.addStatement("return map");

        return toMapBuilder.build();
    }

    private MethodSpec toBean(TypeElement typeElement) {

        TypeMirror targetType = typeElement.asType();
        // 创建 toBean 方法
        MethodSpec.Builder toBeanMethodBuilder = MethodSpec.methodBuilder("toBean")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ParameterizedTypeName.get(Map.class, String.class, Object.class), "dataMap")
                .returns(TypeVariableName.get(targetType))
                .beginControlFlow("if ($T.isEmpty(dataMap))", ClassName.get("cn.hutool.core.collection", "CollUtil")) // 添加空检查
                .addStatement("return new $T()", targetType) // 如果 dataMap 为空，返回新实例
                .endControlFlow()
                .addStatement("$T bean = new $T()", targetType, targetType); // 初始化 Bean


        System.out.println("typeElement : " + typeElement);


        // 遍历Map的 字段
        CollectFields.toBeanCollectFields(typeElement, toBeanMethodBuilder, processingEnv);

        toBeanMethodBuilder.addStatement("return bean");
        return toBeanMethodBuilder.build();
    }

    private void write(String packageName, TypeSpec mapConverterClass) {

        // 写入 Java 文件
        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME + "." + packageName, mapConverterClass).build();
        try {
            javaFile.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Failed to generate toBean method: " + e.getMessage());
            throw new RuntimeException(e);
        }
    }
}
