package cc.anqin.processor;

import cc.anqin.processor.annotation.AutoToMap;
import cc.anqin.processor.base.ConvertMap;
import cc.anqin.processor.util.CollectFields;
import com.squareup.javapoet.*;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * <p>Map转换器处理器</p>
 *
 * @author Mr.An
 * @since 2024/11/18
 */
@SupportedAnnotationTypes("cc.anqin.processor.annotation.AutoToMap")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MapConverterProcessor extends AbstractProcessor {

    // 保存所有生成的转换器信息
    private static final Map<String, String> converterRegistry = new HashMap<>();

    /** 包前缀 */
    public static final String PACKAGE_PREFIX = "auto.mappings.";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(AutoToMap.class)) {
            if (element instanceof TypeElement) {
                TypeElement typeElement = (TypeElement) element;
                generateMethod(typeElement);

                // 注册转换器信息
                String originalClassName = typeElement.getQualifiedName().toString();
                String converterClassName = ConvertMap.getConvertName(originalClassName);

                converterRegistry.put(originalClassName, PACKAGE_PREFIX + converterClassName);
            }
        }

        // 在所有注解处理完成后生成注册表
        if (roundEnv.processingOver()) {
            generateJsonRegistryFile();
        }

        return true;
    }


    private void generateMethod(TypeElement typeElement) {
        String className = ConvertMap.getConvertName(typeElement.getSimpleName().toString());

        String packageName = processingEnv.getElementUtils().getPackageOf(typeElement).toString();

        System.out.println("Generating file: " + className);

        // 创建  @Generated 注解
        AnnotationSpec componentAnnotation = AnnotationSpec
                .builder(ClassName.get("cc.anqin.processor.annotation", "Generated"))
                .addMember("value", "$S", "cc.anqin.processor.MapConverterProcessor") // 添加生成器名称
                .addMember("date", "$S", LocalDateTime.now())        // 添加当前日期
                .addMember("comments", "$S", "Generated by MapConverterProcessor; Introduction: https://anqin.cc/")   // 添加注释
                .addMember("repository", "$S", "https://github.com/anqinworks/auto-mapping-map")
                .addMember("source", "$S", typeElement.getQualifiedName().toString())
                .build();


        // 创建实现 MappingConvert 接口的类
        TypeSpec mapConverterClass = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(componentAnnotation)
                .addSuperinterface(ParameterizedTypeName.get(
                        ClassName.get("cc.anqin.processor.base", "MappingConvert"),
                        TypeName.get(typeElement.asType())
                ))
                .addMethod(toMap(typeElement))
                .addMethod(toBean(typeElement))
                .build();

        write(PACKAGE_PREFIX + packageName, mapConverterClass);
    }

    private MethodSpec toMap(TypeElement typeElement) {
        // 创建 toMap 方法
        MethodSpec.Builder toMapBuilder = MethodSpec.methodBuilder("toMap")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .returns(ParameterizedTypeName.get(Map.class, String.class, Object.class))
                .addParameter(TypeName.get(typeElement.asType()), "entity")
                .beginControlFlow("if (entity == null)") // 添加空检查
                .addStatement("return $T.emptyMap()", ClassName.get("java.util", "Collections")) // 如果 dataMap 为空，返回新实例
                .endControlFlow();

        // 初始化 Map
        toMapBuilder.addStatement("$T<String, Object> map = new $T<>()", Map.class, HashMap.class);

        // 遍历字段（包含父类）
        CollectFields.toMapCollectFields(typeElement, toMapBuilder, processingEnv);

        toMapBuilder.addStatement("return map");

        return toMapBuilder.build();
    }

    private MethodSpec toBean(TypeElement typeElement) {
        TypeMirror targetType = typeElement.asType();
        // 创建 toBean 方法
        MethodSpec.Builder toBeanMethodBuilder = MethodSpec.methodBuilder("toBean")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ParameterizedTypeName.get(Map.class, String.class, Object.class), "dataMap")
                .returns(TypeVariableName.get(targetType))
                .beginControlFlow("if ($T.isEmpty(dataMap))", ClassName.get("cn.hutool.core.collection", "CollUtil")) // 添加空检查
                .addStatement("return new $T()", targetType) // 如果 dataMap 为空，返回新实例
                .endControlFlow()
                .addStatement("$T bean = new $T()", targetType, targetType); // 初始化 Bean


        System.out.println("typeElement : " + typeElement);


        // 遍历Map的 字段
        CollectFields.toBeanCollectFields(typeElement, toBeanMethodBuilder, processingEnv);

        toBeanMethodBuilder.addStatement("return bean");
        return toBeanMethodBuilder.build();
    }

    private void write(String packageName, TypeSpec mapConverterClass) {

        // 写入 Java 文件
        JavaFile javaFile = JavaFile.builder(packageName, mapConverterClass).build();
        try {
            javaFile.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Failed to generate toBean method: " + e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * 直接生成JSON注册文件
     */
    private void generateJsonRegistryFile() {
        if (converterRegistry.isEmpty()) {
            return;
        }

        try {
            // 手动构建JSON内容
            StringBuilder jsonBuilder = new StringBuilder();
            jsonBuilder.append("{\n");

            boolean first = true;
            for (Map.Entry<String, String> entry : converterRegistry.entrySet()) {
                if (!first) {
                    jsonBuilder.append(",\n");
                }
                jsonBuilder.append("  \"")
                        .append(escapeJsonString(entry.getKey()))
                        .append("\": \"")
                        .append(escapeJsonString(entry.getValue()))
                        .append("\"");
                first = false;
            }

            jsonBuilder.append("\n}");

            // 创建JSON文件
            Filer filer = processingEnv.getFiler();
            FileObject fileObject = filer.createResource(
                    StandardLocation.CLASS_OUTPUT,
                    "",
                    "META-INF/map-converter-registry.json"
            );

            try (Writer writer = fileObject.openWriter()) {
                writer.write(jsonBuilder.toString());
            }

            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                    "Generated JSON registry with " + converterRegistry.size() + " entries");

        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                    "Failed to generate JSON registry: " + e.getMessage());
        }
    }

    /**
     * JSON字符串转义
     */
    private String escapeJsonString(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\b", "\\b")
                .replace("\f", "\\f")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}